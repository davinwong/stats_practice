classdef Classifier
    
    properties
        mu
        sigma
        prob
        cluster
    end
    methods
        
        function class = Classifier(mu, sigma, prob, size) 
            class.mu = mu;
            class.sigma = sigma;
            class.prob = prob;
            class.cluster = gaussTransform(randn(size,2),class.mu,class.sigma);
        end
        
        %Plot Functions
        function plotStdDev(class, colour)
            x=class.mu(1);
            y=class.mu(2);
            [V,D] = eig(class.sigma);
            distA = sqrt(D(1,1));
            distB = sqrt(D(2,2));
            
            theta = atan(V(2,1)/V(1,1));
            
            np = 100;
            ang = [0:np]*2*pi/np;
            pts = [x;y]*ones(size(ang)) + [cos(theta) -sin(theta);...
                sin(theta) cos(theta)]*[cos(ang)*distA; sin(ang)*distB];
            plot( pts(1,:), pts(2,:), colour);
        end
        
        function plotData(class, colour)
            x = class.cluster*[1;0];
            y = class.cluster*[0;1];
            scatter(x,y,5,strcat('*',colour));
        end
    
    %% Distance Calculations
        % MED
        function d = MED(class, point)
            d = (point - class.mu)'*(point - class.mu); %dist squared
        end
        
        % GED
        function d = GED(class, point)
            d = (point - class.mu)'*class.sigma^(-1)*(point - class.mu);
        end
        
        function p = MAP(class, point)
           p = class.Probability * sqrt(2 * pi * det(class.sigma))^(-1) * exp(-0.5 * class.GED(point)); %probability-ish
        end
    end
    
    methods (Static = true)
        %Classifiers
        
        function map = BoundMatrixMED(classes, x_pts, y_pts)
           map = zeros(length(x_pts),length(y_pts));
           for i = 1:length(x_pts)
               for j = 1:length(y_pts)
                    c = 0; %The class index
                    d = Inf; %The distance
                    for k = 1:length(classes)
                        point = [x_pts(i) y_pts(j)]';
                        med = (point - classes{k}.mu)'*(point - class.mu);
                        if med <= d
                           c = i;
                           d = classes{k}.MED(point);
                        end
                    end
                    map(i,j) = c;
               end
           end
        end
        
        function c = medClassifier(point, classes)
            c = 0; %The class index
            d = Inf; %The distance
            for i = 1:length(classes)
                if classes{i}.MED(point) <= d
                   c = i;
                   d = classes{i}.MED(point);
                end
            end
        end
        
        function map = gedClassifier(classes, x_pts, y_pts)
            map = zeros(length(x_pts),length(y_pts));
            for i = 1:length(x_pts)
                for j = 1:length(y_pts)
                    c = 0; %The class index
                    d = Inf; %The distance
                    point = [x_pts(i) y_pts(j)];
                    for k = 1:length(classes)
                        if classes{k}.GED(point) <= d
                        c = k;
                        d = classes{k}.GED(point);
                        end
                    end
                    map(i,j) = c;
                end
            end
        end
        
        function map = maclasslassifier(classes, x, y)
            map = zeros(length(x),length(y));
            for i = 1:length(x)
                for j = 1:length(y)
                    m = 0;
                    d = 0;
                    point = [x(i) y(j)]';
                    for k = 1:length(classes)
                        t = classes{k}.prob * sqrt(2 * pi * det(classes{k}...
                            .sigma))^(-1) * exp(-.5 * classes{k}.ged(point));
                        if t >= d
                            m = i;
                            d = t;
                        end
                    end
                    map(i,j) = m;
                end
            end
        end
    end
    
end